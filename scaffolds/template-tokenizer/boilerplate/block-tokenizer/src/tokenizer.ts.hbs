import { {{#if useBlockTokenizerPreMatchPhaseHook}}
  ParagraphDataNodeType
{{/if}} } from '@yozora/tokenizer-paragraph'
import { DataNodeTokenPointDetail } from '@yozora/tokenizercore'
import {
  BaseBlockTokenizer,
  BlockTokenizer,
{{#if useBlockTokenizerPreMatchPhaseHook}}
  EatAndInterruptPreviousSiblingResult,
  EatContinuationTextResult,
  EatLazyContinuationTextResult,
  EatNewMarkerResult,
  EatingLineInfo,
{{/if}}
{{#if useBlockTokenizerMatchPhaseHook}}
  BlockTokenizerMatchPhaseHook,
{{/if}}
{{#if useBlockTokenizerPostMatchPhaseHook}}
  BlockTokenizerMatchPhaseState,
{{/if}}
{{#if useBlockTokenizerParsePhaseHook}}
  BlockTokenizerParsePhaseHook,
{{/if}}
{{#if useBlockTokenizerParsePhaseHook}}
  BlockTokenizerParsePhaseState,
{{/if}}
{{#if useBlockTokenizerPostMatchPhaseHook}}
  BlockTokenizerPostMatchPhaseHook,
{{/if}}
{{#if useBlockTokenizerPreMatchPhaseHook}}
  BlockTokenizerPreMatchPhaseHook,
{{/if}}
{{#xif 'useBlockTokenizerPreParsePhaseHook || useBlockTokenizerMatchPhaseHook'}}
  BlockTokenizerPreMatchPhaseState,
{{/xif}}
{{#if useBlockTokenizerPreParsePhaseHook}}
  BlockTokenizerPreParsePhaseHook,
{{/if}}
{{#if useBlockTokenizerParsePhaseHook}}
  BlockTokenizerPreParsePhaseState,
{{/if}}
{{#if useBlockTokenizerParsePhaseHook}}
  PhrasingContentDataNode,
{{/if}}
{{#if useBlockTokenizerMatchPhaseHook}}
  PhrasingContentDataNodeType,
{{/if}}
{{#if useBlockTokenizerPreMatchPhaseHook}}
  PhrasingContentLine,
{{/if}}
{{#if useBlockTokenizerMatchPhaseHook}}
  PhrasingContentMatchPhaseState,
{{/if}}
} from '@yozora/tokenizercore-block'
import {
{{#if useBlockTokenizerParsePhaseHook}}
  {{{pascalCase tokenizerName}}}DataNode,
{{/if}}
  {{{pascalCase tokenizerName}}}DataNodeType,
  {{{pascalCase tokenizerName}}}MatchPhaseState,
{{#if useBlockTokenizerPreParsePhaseHook}}
  {{{pascalCase tokenizerName}}}MetaData,
{{/if}}
{{#xif 'useBlockTokenizerPreParsePhaseHook || useBlockTokenizerMatchPhaseHook'}}
  {{{pascalCase tokenizerName}}}PreMatchPhaseState,
{{/xif}}
} from './types'


type T = {{{pascalCase tokenizerName}}}DataNodeType


/**
 * Lexical Analyzer for {{{pascalCase tokenizerName}}}DataNode
 */
export class {{{pascalCase tokenizerName}}}Tokenizer extends BaseBlockTokenizer<T>
  implements
    BlockTokenizer<T>{{#if usingHooks}},{{/if}}
{{#if useBlockTokenizerPreMatchPhaseHook}}
    BlockTokenizerPreMatchPhaseHook<
      T,
      {{{pascalCase tokenizerName}}}PreMatchPhaseState>{{#if BlockTokenizerPreMatchPhaseHook__isNotLastHook}},{{/if}}
{{/if}}
{{#if useBlockTokenizerMatchPhaseHook}}
    BlockTokenizerMatchPhaseHook<
      T,
      {{{pascalCase tokenizerName}}}PreMatchPhaseState,
      {{{pascalCase tokenizerName}}}MatchPhaseState>{{#if BlockTokenizerMatchPhaseHook__isNotLastHook}},{{/if}}
{{/if}}
{{#if useBlockTokenizerPostMatchPhaseHook}}
    BlockTokenizerPostMatchPhaseHook{{#if BlockTokenizerPostMatchPhaseHook__isNotLastHook}},{{/if}}
{{/if}}
{{#if useBlockTokenizerPreParsePhaseHook}}
    BlockTokenizerPreParsePhaseHook<
      T,
      {{{pascalCase tokenizerName}}}MatchPhaseState,
      {{{pascalCase tokenizerName}}}MetaData>{{#if BlockTokenizerPreParsePhaseHook__isNotLastHook}},{{/if}}
{{/if}}
{{#if useBlockTokenizerParsePhaseHook}}
    BlockTokenizerParsePhaseHook<
      T,
      {{{pascalCase tokenizerName}}}MatchPhaseState,
      {{{pascalCase tokenizerName}}}DataNode>{{#if BlockTokenizerParsePhaseHook__isNotLastHook}},{{/if}}
{{/if}}
{
  public readonly name = '{{{pascalCase tokenizerName}}}Tokenizer'
  public readonly uniqueTypes: T[] = [{{{pascalCase tokenizerName}}}DataNodeType]

{{#if useBlockTokenizerPreMatchPhaseHook}}
  /**
   * hook of @BlockTokenizerPreMatchPhaseHook
   */
  public eatNewMarker(
    codePositions: DataNodeTokenPointDetail[],
    eatingInfo: EatingLineInfo,
    parentState: Readonly<BlockTokenizerPreMatchPhaseState>
  ): EatNewMarkerResult<T, {{{pascalCase tokenizerName}}}PreMatchPhaseState> {
    const { isBlankLine, endIndex } = eatingInfo
    if (isBlankLine) return null

    const line: PhrasingContentLine = {
      codePositions,
      firstNonWhiteSpaceIndex: 0,
    }
    const state: {{{pascalCase tokenizerName}}}PreMatchPhaseState = {
      type: {{{pascalCase tokenizerName}}}DataNodeType,
      opening: true,
      parent: parentState,
      lines: [line],
    }
    return { nextIndex: endIndex, state }
  }

  // /**
  //  * hook of @BlockTokenizerPreMatchPhaseHook
  //  */
  // public eatAndInterruptPreviousSibling(
  //   codePositions: DataNodeTokenPointDetail[],
  //   eatingInfo: EatingLineInfo,
  //   parentState: Readonly<BlockTokenizerPreMatchPhaseState>,
  //   previousSiblingState: Readonly<BlockTokenizerPreMatchPhaseState>,
  // ): EatAndInterruptPreviousSiblingResult<T, {{{pascalCase tokenizerName}}}PreMatchPhaseState> {
  //   const self = this
  //   switch (previousSiblingState.type) {
  //     case ParagraphDataNodeType: {
  //       if (previousSiblingState.type !== ParagraphDataNodeType) return null
  //       const eatingResult = self.eatNewMarker(codePositions, eatingInfo, parentState)
  //       if (eatingResult == null) return null
  //       return { ...eatingResult, shouldRemovePreviousSibling: false }
  //     }
  //     default:
  //       return null
  //   }
  // }

  // /**
  //  * hook of @BlockTokenizerPreMatchPhaseHook
  //  */
  // public eatContinuationText(
  //   codePositions: DataNodeTokenPointDetail[],
  //   eatingInfo: EatingLineInfo,
  //   state: {{{pascalCase tokenizerName}}}PreMatchPhaseState,
  // ): EatContinuationTextResult<T, {{{pascalCase tokenizerName}}}PreMatchPhaseState> {
  //   return null
  // }

  // /**
  //  * hook of @BlockTokenizerPreMatchPhaseHook
  //  */
  // public eatLazyContinuationText(
  //   codePositions: DataNodeTokenPointDetail[],
  //   eatingInfo: EatingLineInfo,
  //   state: {{{pascalCase tokenizerName}}}PreMatchPhaseState,
  // ): EatLazyContinuationTextResult<T, {{{pascalCase tokenizerName}}}PreMatchPhaseState> {
  //   return null
  // }

  // /**
  //  * hook of @BlockTokenizerPreMatchPhaseHook
  //  */
  // public shouldAcceptChild(
  //   state: {{{pascalCase tokenizerName}}}PreMatchPhaseState,
  //   childState: BlockTokenizerPreMatchPhaseState,
  // ): boolean {
  //   return true
  // }

  // /**
  //  * hook of @BlockTokenizerPreMatchPhaseHook
  //  */
  // public beforeAcceptChild(
  //   state: {{{pascalCase tokenizerName}}}PreMatchPhaseState,
  //   childState: BlockTokenizerPreMatchPhaseState,
  // ): void {
  //
  // }
{{/if}}
{{#if useBlockTokenizerMatchPhaseHook}}

  /**
   * hook of @BlockTokenizerMatchPhaseHook
   */
  public match(
    preMatchPhaseState: {{{pascalCase tokenizerName}}}PreMatchPhaseState,
  ): {{{pascalCase tokenizerName}}}MatchPhaseState {
    const phrasingContent: PhrasingContentMatchPhaseState = {
      type: PhrasingContentDataNodeType,
      classify: 'flow',
      lines: preMatchPhaseState.lines,
    }
    const result: {{{pascalCase tokenizerName}}}MatchPhaseState = {
      type: preMatchPhaseState.type,
      classify: 'flow',
      children: [phrasingContent],
    }
    return result
  }
{{/if}}
{{#if useBlockTokenizerPostMatchPhaseHook}}

  /**
   * hook of @BlockTokenizerPostMatchPhaseHook
   */
  public transformMatch(
    matchPhaseStates: Readonly<BlockTokenizerMatchPhaseState[]>,
  ): BlockTokenizerMatchPhaseState[] {
    return matchPhaseStates as BlockTokenizerMatchPhaseState[]
  }
{{/if}}
{{#if useBlockTokenizerPreParsePhaseHook}}

  /**
   * hook of @BlockTokenizerPreParsePhaseHook
   */
  public parseMeta(
    matchPhaseStates: {{{pascalCase tokenizerName}}}MatchPhaseState[]
  ): {{{pascalCase tokenizerName}}}MetaData {
    const metaData: {{{pascalCase tokenizerName}}}MetaData = {}
    return metaData
  }
{{/if}}
{{#if useBlockTokenizerParsePhaseHook}}

  /**
   * hook of @BlockTokenizerParsePhaseHook
   */
  public parseFlow(
    matchPhaseState: {{{pascalCase tokenizerName}}}MatchPhaseState,
    preParsePhaseState: BlockTokenizerPreParsePhaseState,
    children?: BlockTokenizerParsePhaseState[],
  ): {{{pascalCase tokenizerName}}}DataNode {
    const result: {{{pascalCase tokenizerName}}}DataNode = {
      type: matchPhaseState.type,
      children: children as [PhrasingContentDataNode],
    }
    return result
  }
{{/if}}
}
