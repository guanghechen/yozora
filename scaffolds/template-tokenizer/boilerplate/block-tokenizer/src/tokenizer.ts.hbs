import type { NodePoint } from '@yozora/character'
import type { YastNode, YastNodeType } from '@yozora/tokenizercore'
import type {
  BlockTokenizer,
  BlockTokenizerMatchPhaseHook,
  BlockTokenizerParsePhaseHook,
  BlockTokenizerPostMatchPhaseHook,
  PhrasingContentLine,
  ResultOfEatAndInterruptPreviousSibling,
  ResultOfEatContinuationText,
  ResultOfEatLazyContinuationText,
  ResultOfEatOpener,
  ResultOfParse,
  YastBlockState,
} from '@yozora/tokenizercore-block'
import type {
  {{{pascalCase tokenizerName}}} as Node,
  {{{pascalCase tokenizerName}}}State as State,
  {{{pascalCase tokenizerName}}}Type as T,
} from './types'
import {
  calcEndYastNodePoint,
  calcStartYastNodePoint,
} from '@yozora/tokenizercore'
import { {{{pascalCase tokenizerName}}}Type } from './types'


/**
 * Params for constructing {{{pascalCase tokenizerName}}}Tokenizer
 */
export interface {{{pascalCase tokenizerName}}}TokenizerProps {
  /**
   * YastNode types that can be interrupt by this BlockTokenizer.
   */
  readonly interruptableTypes?: YastNodeType[]
}


/**
 * Lexical Analyzer for {{{pascalCase tokenizerName}}}
 */
export class {{{pascalCase tokenizerName}}}Tokenizer implements
  BlockTokenizer<T, State>{{#if usingHooks}},{{/if}}
{{#if useBlockTokenizerMatchPhaseHook}}
  BlockTokenizerMatchPhaseHook<T, State>{{#if BlockTokenizerMatchPhaseHook__isNotLastHook}},{{/if}}
{{/if}}
{{#if useBlockTokenizerPostMatchPhaseHook}}
  BlockTokenizerPostMatchPhaseHook{{#if BlockTokenizerPostMatchPhaseHook__isNotLastHook}},{{/if}}
{{/if}}
{{#if useBlockTokenizerParsePhaseHook}}
  BlockTokenizerParsePhaseHook<T, State, Node>{{#if BlockTokenizerParsePhaseHook__isNotLastHook}},{{/if}}
{{/if}}
{
  public readonly name = '{{{pascalCase tokenizerName}}}Tokenizer'
  public readonly getContext: BlockTokenizer['getContext'] = () => null

  public readonly isContainerBlock = false
  public readonly interruptableTypes: ReadonlyArray<YastNodeType>
  public readonly recognizedTypes: T[] = [{{{pascalCase tokenizerName}}}Type]

  /* istanbul ignore next */
  public constructor(props: {{{pascalCase tokenizerName}}}TokenizerProps = {}) {
    this.interruptableTypes = Array.isArray(props.interruptableTypes)
      ? [...props.interruptableTypes]
      : []
  }
{{#if useBlockTokenizerMatchPhaseHook}}

  /**
   * @override
   * @see BlockTokenizerMatchPhaseHook
   */
  public eatOpener(
    line: Readonly<PhrasingContentLine>,
    parentState: Readonly<YastBlockState>,
  ): ResultOfEatOpener<T, State> {
    const { nodePoints, startIndex, endIndex, firstNonWhitespaceIndex } = line
    if (firstNonWhitespaceIndex >= endIndex) return null

    const nextIndex = endIndex
    const state: State = {
      type: {{{pascalCase tokenizerName}}}Type,
      position: {
        start: calcStartYastNodePoint(nodePoints, startIndex),
        end: calcEndYastNodePoint(nodePoints, nextIndex - 1),
      },
      lines: [{ ...line }],
    }

    return { state, nextIndex }
  }

  // /**
  //  * @override
  //  * @see BlockTokenizerMatchPhaseHook
  //  */
  // public eatAndInterruptPreviousSibling(
  //   line: Readonly<PhrasingContentLine>,
  //   previousSiblingState: Readonly<YastBlockState>,
  //   parentState: Readonly<YastBlockState>,
  // ): ResultOfEatAndInterruptPreviousSibling<T, State> {
  //   return null
  // }

  // /**
  //  * @override
  //  * @see BlockTokenizerMatchPhaseHook
  //  */
  // public eatContinuationText(
  //   line: Readonly<PhrasingContentLine>,
  //   state: State,
  //   parentState: Readonly<YastBlockState>,
  // ): ResultOfEatContinuationText {
  //   return { status: 'notMatched' }
  // }

  // /**
  //  * @override
  //  * @see BlockTokenizerMatchPhaseHook
  //  */
  // public eatLazyContinuationText(
  //   line: Readonly<PhrasingContentLine>,
  //   state: State,
  //   parentState: Readonly<YastBlockState>,
  // ): ResultOfEatLazyContinuationText {
  //   const result = this.eatContinuationText(line, state, parentState)
  //   return result as ResultOfEatLazyContinuationText
  // }
{{/if}}
{{#if useBlockTokenizerPostMatchPhaseHook}}

  /**
   * @override
   * @see BlockTokenizerPostMatchPhaseHook
   */
  public transformMatch(
    states: ReadonlyArray<YastBlockState>,
    nodePoints: ReadonlyArray<NodePoint>,
  ): YastBlockState[] {
    return states.slice()
  }
{{/if}}
{{#if useBlockTokenizerParsePhaseHook}}

  /**
   * @override
   * @see BlockTokenizerParsePhaseHook
   */
  public parse(
    state: Readonly<State>,
    children: YastNode[] | undefined,
    nodePoints: ReadonlyArray<NodePoint>,
  ): ResultOfParse<T, Node> {
    const node: Node = { type: state.type }
    return { classification: 'flow', node }
  }
{{/if}}
}
