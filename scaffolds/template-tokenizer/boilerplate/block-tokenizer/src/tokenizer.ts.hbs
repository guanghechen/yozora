import {
  BaseBlockDataNodeTokenizer,
  BlockDataNode,
  BlockDataNodeEatingLineInfo,
  BlockDataNodeMatchResult,
  BlockDataNodeMatchState,
  BlockDataNodeTokenizer,
  DataNodeTokenPointDetail,
  InlineDataNodeParseFunc,
} from '@yozora/tokenizer-core'
import { {{{pascalCase tokenizerName}}}DataNode, {{{pascalCase tokenizerName}}}DataNodeData, {{{pascalCase tokenizerName}}}DataNodeType } from './types'


type T = {{{pascalCase tokenizerName}}}DataNodeType


export interface {{{pascalCase tokenizerName}}}DataNodeMatchResult extends BlockDataNodeMatchResult<T> {

}


export interface {{{pascalCase tokenizerName}}}DataNodeMatchState extends BlockDataNodeMatchState<T> {

}


/**
 * Lexical Analyzer for {{{pascalCase tokenizerName}}}DataNode
 */
export class {{{pascalCase tokenizerName}}}Tokenizer extends BaseBlockDataNodeTokenizer<
  T,
  {{{pascalCase tokenizerName}}}DataNodeData,
  {{{pascalCase tokenizerName}}}DataNodeMatchState,
  {{{pascalCase tokenizerName}}}DataNodeMatchResult>
  implements BlockDataNodeTokenizer<
  T,
  {{{pascalCase tokenizerName}}}DataNodeData,
  {{{pascalCase tokenizerName}}}DataNodeMatchState,
  {{{pascalCase tokenizerName}}}DataNodeMatchResult> {
  public readonly name = '{{{pascalCase tokenizerName}}}Tokenizer'
  public readonly recognizedTypes: T[] = [{{{pascalCase tokenizerName}}}DataNodeType]

  /**
   * override
   */
  public eatNewMarker(
    codePoints: DataNodeTokenPointDetail[],
    {
      startIndex,
      endIndex,
      firstNonWhiteSpaceIndex,
      isBlankLine,
    }: BlockDataNodeEatingLineInfo,
  ): [number, {{{pascalCase tokenizerName}}}DataNodeMatchState | null] {
    return [startIndex, null]
  }

  /**
   * override
   */
  public eatContinuationText(
    codePoints: DataNodeTokenPointDetail[],
    {
      startIndex,
      endIndex,
      firstNonWhiteSpaceIndex,
      isBlankLine,
    }: BlockDataNodeEatingLineInfo,
    state: {{{pascalCase tokenizerName}}}DataNodeMatchState,
  ): [number, boolean] {
    return [startIndex, false]
  }

  // /**
  //  * override
  //  */
  // public eatLazyContinuationText(
  //   codePoints: DataNodeTokenPointDetail[],
  //   eatingLineInfo: BlockDataNodeEatingLineInfo,
  //   state: {{{pascalCase tokenizerName}}}DataNodeMatchState,
  // ): [number, boolean] {
  //   return this.eatContinuationText(codePoints, eatingLineInfo, state)
  // }

  // /**
  //  * override
  //  */
  // public closeMatchState(state: {{{pascalCase tokenizerName}}}DataNodeMatchState): void {
  //
  // }


  /**
   * override
   */
  public parse(
    codePoints: DataNodeTokenPointDetail[],
    matchResult: {{{pascalCase tokenizerName}}}DataNodeMatchResult,
    children?: BlockDataNode[],
    parseInline?: InlineDataNodeParseFunc,
  ): {{{pascalCase tokenizerName}}}DataNode {
    return {} as any
  }
}
